

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Base classes for solving inverse problems (fatiando.inversion.base) &mdash; Fatiando a Terra v0.3</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Fatiando a Terra v0.3" href="../index.html"/>
        <link rel="up" title="Inverse problems framework (fatiando.inversion)" href="inversion.html"/>
        <link rel="next" title="Optimization routines (fatiando.inversion.solvers)" href="inversion.solvers.html"/>
        <link rel="prev" title="Inverse problems framework (fatiando.inversion)" href="inversion.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="fa fa-home"> Fatiando a Terra</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-0-3">Version 0.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-0-2">Version 0.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-0-1">Version 0.1</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing Fatiando</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../install.html#which-python">Which Python?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install.html#installing-the-dependencies">Installing the dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install.html#id1">Installing Fatiando</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install.html#installing-the-latest-development-version">Installing the latest development version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../install.html#testing-the-install">Testing the install</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="fatiando.html">API Reference: The <tt class="docutils literal"><span class="pre">fatiando</span></tt> package</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gravmag.html">Gravity and magnetics (<tt class="docutils literal"><span class="pre">fatiando.gravmag</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="seismic.html">Seismics and seismology (<tt class="docutils literal"><span class="pre">fatiando.seismic</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="geothermal.html">Geothermal heat (<tt class="docutils literal"><span class="pre">fatiando.geothermal</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mesher.html">Meshing (<tt class="docutils literal"><span class="pre">fatiando.mesher</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="gridder.html">Gridding (<tt class="docutils literal"><span class="pre">fatiando.gridder</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="vis.html">Visualization (<tt class="docutils literal"><span class="pre">fatiando.vis</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="datasets.html">Fetch data from the internet (<tt class="docutils literal"><span class="pre">fatiando.datasets</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="gui.html">Graphical user interfaces (<tt class="docutils literal"><span class="pre">fatiando.gui</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="utils.html">Miscellaneous Utilities (<tt class="docutils literal"><span class="pre">fatiando.utils</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="constants.html">Physical constants and unit conversions (<tt class="docutils literal"><span class="pre">fatiando.constants</span></tt>)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="inversion.html">Inverse problems framework (<tt class="docutils literal"><span class="pre">fatiando.inversion</span></tt>)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cookbook.html">Cookbook</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/datasets_crust2.0_tesseroid.html">Datasets: Fetch the CRUST2.0 model, convert it to tesseroids and calculate its gravity signal in parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/geothermal_climsig_abrupt.html">Geothermal: Forward and inverse modeling of an abrupt change in temperature measured in a well</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/geothermal_climsig_linear.html">Geothermal: Forward and inverse modeling of a linear change in temperature measured in a well</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/geothermal_climsig_wrong.html">Geothermal: Climate signal: What happens when assuming a climate change is linear, when in fact it was abrupt?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_2d_polygon_interactive.html">GravMag: Interactive 2D forward modeling with polygons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_2d_polygon_picker.html">GravMag: 2D forward modeling with polygons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_basin2d_trapezoidal.html">GravMag: Simple gravity inversion for the relief of a 2D trapezoidal basin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_basin2d_trapezoidal_forward.html">GravMag: Interactive 2D forward gravity modeling of a trapezoidal basin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_basin2d_triangular.html">GravMag: Simple gravity inversion for the relief of a 2D triangular basin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_basin2d_triangular_forward.html">GravMag: Interactive 2D forward gravity modeling of a triangular basin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_eqlayer_joint.html">GravMag: Fit an equivalent layer to gravity and gravity gradient data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_eqlayer_pel_polereduc.html">GravMag: Use the Polynomial Equivalent Layer to reduce a magnetic total field anomaly to the pole</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_eqlayer_pel_upcontinue.html">GravMag: Use the polynomial equivalent layer to upward continue gravity data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_eqlayer_polereduc.html">GravMag: Use an equivalent layer to reduce a magnetic total field anomaly to the pole</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_eqlayer_upcontinue.html">GravMag: Use an equivalent layer to upward continue gravity data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_euler_classic.html">GravMag: Classic 3D Euler deconvolution of magnetic data (single window)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_euler_classic_expanding_window.html">GravMag: Classic 3D Euler deconvolution of magnetic data using an expanding window</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_euler_classic_moving_window.html">GravMag: Classic 3D Euler deconvolution of magnetic data using a moving window</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_fourier_ansig.html">GravMag: Calculate the analytic signal of a total field anomaly using FFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_fourier_deriv.html">GravMag: Calculating the derivatives of the gravity anomaly using FFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_grav_polyprism.html">GravMag: Forward gravity modeling using a stack of 3D polygonal model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_grav_prism.html">GravMag: Forward modeling of the gravitational potential and its derivatives using 3D model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_grav_sphere.html">GravMag: Forward modeling of the gravity anomaly and gravity gradient tensor using model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_grav_tesseroid.html">GravMag: Forward modeling of the gravitational potential and its derivatives using tesseroids</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_harvester_grav.html">GravMag: 3D gravity inversion by planting anomalous densities using <tt class="docutils literal"><span class="pre">harvester</span></tt> (more complex interactive example)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_harvester_tensor.html">GravMag: 3D gravity gradient inversion by planting anomalous densities using <tt class="docutils literal"><span class="pre">harvester</span></tt> (with non-targeted sources)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_harvester_weights.html">GravMag: Using data weights in 3D inversion using <tt class="docutils literal"><span class="pre">harvester</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_imaging_geninv.html">GravMag: 3D imaging using the Generalized Inverse method on synthetic gravity data (more complex model + noisy data)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_imaging_migration.html">GravMag: 3D imaging using the migration method on synthetic gravity data (more complex model + noisy data)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_imaging_sandwich.html">GravMag: 3D imaging using the sandwich model method on synthetic gravity data (simple example)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_mag_polyprism.html">GravMag: 3D forward modeling of total-field magnetic anomaly using polygonal prisms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_mag_prism.html">GravMag: 3D forward modeling of total-field magnetic anomaly using rectangular prisms (model with induced and remanent magnetization)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_mag_sphere.html">GravMag: 3D forward modeling of total-field magnetic anomaly using spheres</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_magdir_dipolemagdir.html">GravMag: Use the DipoleMagDir class to estimate the magnetization direction of dipoles with known centers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_normal_gravity.html">GravMag: Calculate the gravity disturbance and Bouguer anomaly for Hawaii</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_tensor_centerofmass.html">GravMag: Center of mass estimation using the first eigenvector of the gravity gradient tensor (simple model)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_tensor_centerofmass_expanding_window.html">GravMag: Center of mass estimation using the first eigenvector of the gravity gradient tensor (2 sources with expanding windows)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_tensor_invariants.html">GravMag: Calculate the gravity gradient tensor invariants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_tensor_polyprism.html">GravMag: Generate synthetic gradient tensor data from polygonal prisms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_tensor_prism_noisy.html">GravMag: Generate noise-corrupted gravity gradient tensor data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/gravmag_upcontinue.html">GravMag: Upward continuation of noisy gz data using the analytical formula</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/grid_cut.html">Gridding: Cut a section from a grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/grid_interpolate.html">Gridding: Grid irregularly sampled data.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/grid_profile.html">Gridding: Extract a profile from map data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/grid_scatter.html">Gridding: Generate and plot irregular grids (scatter)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/grid_surfer.html">Gridding: Load a Surfer ASCII grid file</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_pointgrid.html">Meshing: Making a grid of 3D point sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_prismmesh.html">Meshing: Make and plot a 3D prism mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_prismmesh_filter.html">Meshing: Filter prisms from a 3D prism mesh based on their physical properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_prismmesh_topo.html">Meshing: Make and plot a 3D prism mesh with topography</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_prismmesh_vardens.html">Meshing: Make a 3D prism mesh with depth-varying density</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_prismrelief_topo.html">Meshing: Generate a 3D prism model of the topography</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_squaremesh_from_image.html">Meshing: Generate a SquareMesh and get the physical properties from an image</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_tesseroid.html">Meshing: Make and plot a tesseroid with the Earth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_tesseroidmesh.html">Meshing: Make and plot a tesseroid mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/mesher_tesseroidmesh_topo.html">Meshing: Make and plot a tesseroid mesh with topography</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_epic2d.html">Seismic: 2D epicenter estimation assuming a homogeneous and flat Earth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_epic2d_iterate.html">Seismic: Show steps taken by different algorithms for 2D epicenter estimation on a flat Earth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_profile_vertical.html">Seismic: Invert vertical seismic profile (VSP) traveltimes for the velocity of a layered model.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_profile_vertical_interactive.html">Seismic: Interactive forward modeling of 1D vertical seismic profile (VSP) data in layered media</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_profile_vertical_smooth.html">Seismic: Invert vertical seismic profile (VSP) traveltimes using smoothness regularization and unknown layer thicknesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_srtomo_damped.html">Seismic: 2D straight-ray tomography using damping regularization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_srtomo_sharp.html">Seismic: 2D straight-ray tomography using sharpness (total variation) regularization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_srtomo_smooth.html">Seismic: 2D straight-ray tomography using smoothness regularization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_wavefd_elastic_psv.html">Seismic: 2D finite difference simulation of elastic P and SV wave propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_wavefd_elastic_sh.html">Seismic: 2D finite difference simulation of elastic SH wave propagation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_wavefd_love_wave.html">Seismic: 2D finite difference simulation of elastic SH wave propagation in a medium with a discontinuity (i.e., Moho), generating Love waves.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_wavefd_rayleigh_wave.html">Seismic: 2D finite difference simulation of elastic P and SV wave propagation in a medium with a discontinuity (i.e., Moho), generating Rayleigh waves</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/seismic_wavefd_scalar.html">Seismic: 2D finite difference simulation of scalar wave propagation.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/vis_mpl_basemap.html">Vis: Plot a map using the Orthographic map projection and filled contours</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/vis_mpl_basemap2.html">Vis: Plot a map using the Mercator map projection and pseudo-color</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/vis_mpl_basemap3.html">Vis: Plot a map using the Robinson map projection and contours</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/vis_mpl_contour.html">Vis: Plot contour lines and filled contours</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/vis_mpl_irregular_data.html">Vis: Plotting irregularly sampled map data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/vis_myv_color.html">Vis: Set the colors in figures, prisms, polygonal prisms and tesseroids.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/vis_myv_earth.html">Vis: Plot the Earth, continents, inner and outer core in 3D with Mayavi2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/vis_myv_exaggerate.html">Vis: Exaggerate the vertical dimension of 3D plots</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../develop.html">Developer guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../develop.html#making-a-release">Making a release</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Fatiando a Terra</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="fatiando.html">API Reference: The <tt class="docutils literal"><span class="pre">fatiando</span></tt> package</a> &raquo;</li>
      
          <li><a href="inversion.html">Inverse problems framework (<tt class="docutils literal"><span class="pre">fatiando.inversion</span></tt>)</a> &raquo;</li>
      
    <li>Base classes for solving inverse problems (<tt class="docutils literal"><span class="pre">fatiando.inversion.base</span></tt>)</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../_sources/api/inversion.base.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="module-fatiando.inversion.base">
<span id="base-classes-for-solving-inverse-problems-fatiando-inversion-base"></span><span id="fatiando-inversion-base"></span><h1>Base classes for solving inverse problems (<tt class="docutils literal"><span class="pre">fatiando.inversion.base</span></tt>)<a class="headerlink" href="#module-fatiando.inversion.base" title="Permalink to this headline">¶</a></h1>
<p>The base classes for inverse problem solving.</p>
<p>All classes derive from <a class="reference internal" href="#fatiando.inversion.base.Objective" title="fatiando.inversion.base.Objective"><tt class="xref py py-class docutils literal"><span class="pre">Objective</span></tt></a>. This class
represents an objective function, a scalar function of a parameter vector.</p>
<p>The main powerhouse of this module is the
<a class="reference internal" href="#fatiando.inversion.base.Misfit" title="fatiando.inversion.base.Misfit"><tt class="xref py py-class docutils literal"><span class="pre">Misfit</span></tt></a> class. It represents a data misfit
function and knows how to fit a specified model to data using various solvers
(see <a class="reference internal" href="inversion.solvers.html#module-fatiando.inversion.solvers" title="fatiando.inversion.solvers"><tt class="xref py py-mod docutils literal"><span class="pre">solvers</span></tt></a>). A model is specified by subclassing
Misfit and implementing the
<tt class="xref py py-meth docutils literal"><span class="pre">_get_predicted</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">_get_jacobian</span></tt> methods, which are
problem specific.</p>
<p>See <a class="reference internal" href="inversion.html#module-fatiando.inversion" title="fatiando.inversion"><tt class="xref py py-mod docutils literal"><span class="pre">fatiando.inversion</span></tt></a> for examples, regularization, and more.</p>
<hr class="docutils" />
<dl class="class">
<dt id="fatiando.inversion.base.Misfit">
<em class="property">class </em><tt class="descclassname">fatiando.inversion.base.</tt><tt class="descname">Misfit</tt><big>(</big><em>data</em>, <em>positional</em>, <em>model</em>, <em>nparams</em>, <em>weights=None</em>, <em>islinear=False</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#fatiando.inversion.base.Objective" title="fatiando.inversion.base.Objective"><tt class="xref py py-class docutils literal"><span class="pre">fatiando.inversion.base.Objective</span></tt></a></p>
<p>An l2-norm data-misfit function.</p>
<p>This is a kind of objective function that measures the misfit between
observed data <span class="math">\(\bar{d}^o\)</span> and data predicted by a set of model
parameters <span class="math">\(\bar{d} = \bar{f}(\bar{p})\)</span>.</p>
<p>The l2-norm data-misfit is defined as:</p>
<div class="math">
\[\phi(\bar{p}) = \dfrac{\bar{r}^T\bar{r}}{N}\]</div>
<p>where <span class="math">\(\bar{r} = \bar{d}^o - \bar{d}\)</span> is the residual vector and
<span class="math">\(N\)</span> is the number of data.</p>
<p>This class inherits the solvers from
<a class="reference internal" href="#fatiando.inversion.base.Objective" title="fatiando.inversion.base.Objective"><tt class="xref py py-class docutils literal"><span class="pre">Objective</span></tt></a> that estimate a parameter
vector <span class="math">\(\bar{p}\)</span> that minimizes it.
See <a class="reference internal" href="#fatiando.inversion.base.Objective" title="fatiando.inversion.base.Objective"><tt class="xref py py-class docutils literal"><span class="pre">Objective</span></tt></a> for more details.</p>
<p>When subclassing this class, you must implement two methods:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">_get_predicted(self,</span> <span class="pre">p)</span></tt>: calculates the predicted data
<span class="math">\(\bar{d}\)</span> for a given parameter vector <tt class="docutils literal"><span class="pre">p</span></tt></li>
<li><tt class="docutils literal"><span class="pre">_get_jacobian(self,</span> <span class="pre">p)</span></tt>: calculates the Jacobian matrix of
<span class="math">\(\bar{f}(\bar{p})\)</span> evaluated at <tt class="docutils literal"><span class="pre">p</span></tt></li>
</ul>
<p>If <span class="math">\(\bar{f}\)</span> is linear, then the Jacobian will be cached in memory so
that it is only calculated once when using the class multiple times. So
solving the same problem with different methods or using an iterative
method doesn&#8217;t have the penalty of recalculating the Jacobian.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">See <a class="reference internal" href="inversion.html#module-fatiando.inversion" title="fatiando.inversion"><tt class="xref py py-mod docutils literal"><span class="pre">fatiando.inversion</span></tt></a> for examples of usage.</p>
</div>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The observed data vector <span class="math">\(\bar{d}^o\)</span></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>positional <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary with the positional arguments of the data, for example, x,
y coordinates, depths, etc. Keys should the string name of the argument
and values should be 1d-arrays with the same size as <em>data</em>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>model <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary with the model parameters, like the mesh, physical
properties, etc.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>nparams <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of parameters in parameter vector <span class="math">\(\bar{p}\)</span></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">Weights to be applied to the each element in <em>data</em> when computing the
l2-norm. Effectively the diagonal of a matrix <span class="math">\(\bar{\bar{W}}\)</span>
such that <span class="math">\(\phi = \bar{r}^T\bar{\bar{W}}\bar{r}\)</span></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>islinear <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">Whether <span class="math">\(\bar{f}\)</span> is linear or not.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="fatiando.inversion.base.Misfit.config">
<tt class="descname">config</tt><big>(</big><em>method</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.config" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the optimization method and its parameters.</p>
<p>This sets the method used by
<a class="reference internal" href="#fatiando.inversion.base.Misfit.fit" title="fatiando.inversion.base.Misfit.fit"><tt class="xref py py-meth docutils literal"><span class="pre">fit</span></tt></a> and the keyword arguments
that are passed to it.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The optimization method. One of: <tt class="docutils literal"><span class="pre">'linear'</span></tt>, <tt class="docutils literal"><span class="pre">'newton'</span></tt>,
<tt class="docutils literal"><span class="pre">'levmarq'</span></tt>, <tt class="docutils literal"><span class="pre">'steepest'</span></tt>, <tt class="docutils literal"><span class="pre">'acor'</span></tt></p>
</dd>
</dl>
</li>
</ul>
<p>Other keyword arguments that can be passed are the ones allowed by each
method.</p>
<p>Some methods have required arguments:</p>
<ul class="simple">
<li><em>newton</em>, <em>levmarq</em> and <em>steepest</em> require the <tt class="docutils literal"><span class="pre">initial</span></tt> argument
(an initial estimate for the gradient descent)</li>
<li><em>acor</em> requires the <tt class="docutils literal"><span class="pre">bounds</span></tt> argument (min/max values for the
search space)</li>
</ul>
<p>See the corresponding docstrings for more information:</p>
<ul class="simple">
<li><a class="reference internal" href="#fatiando.inversion.base.Misfit.linear" title="fatiando.inversion.base.Misfit.linear"><tt class="xref py py-meth docutils literal"><span class="pre">linear</span></tt></a></li>
<li><a class="reference internal" href="#fatiando.inversion.base.Objective.newton" title="fatiando.inversion.base.Objective.newton"><tt class="xref py py-meth docutils literal"><span class="pre">newton</span></tt></a></li>
<li><a class="reference internal" href="#fatiando.inversion.base.Objective.levmarq" title="fatiando.inversion.base.Objective.levmarq"><tt class="xref py py-meth docutils literal"><span class="pre">levmarq</span></tt></a></li>
<li><a class="reference internal" href="#fatiando.inversion.base.Objective.steepest" title="fatiando.inversion.base.Objective.steepest"><tt class="xref py py-meth docutils literal"><span class="pre">steepest</span></tt></a></li>
<li><a class="reference internal" href="#fatiando.inversion.base.Objective.acor" title="fatiando.inversion.base.Objective.acor"><tt class="xref py py-meth docutils literal"><span class="pre">acor</span></tt></a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <em>iterate</em> keyword is not supported by <em>fit</em>.
Use the individual methods to step through iterations.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Misfit</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">{},</span> <span class="p">{},</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">config</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;newton&#39;</span><span class="p">,</span> <span class="n">precondition</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">initial</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">maxit</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">fit_method</span>
<span class="go">&#39;newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit_args</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">,</span> <span class="n">v</span>
<span class="go">initial : [0, 0]</span>
<span class="go">maxit : 10</span>
<span class="go">precondition : False</span>
<span class="go">tol : 0.01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Omitted arguments will fall back to the method defaults</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;levmarq&#39;</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fit_args</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">,</span> <span class="n">v</span>
<span class="go">dlamb : 2</span>
<span class="go">initial : [1, 1]</span>
<span class="go">lamb : 1</span>
<span class="go">maxit : 30</span>
<span class="go">maxsteps : 10</span>
<span class="go">precondition : True</span>
<span class="go">tol : 1e-05</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># For non-linear gradient solvers, *initial* is required</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;newton&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AttributeError</span>: <span class="n">Missing required *initial* argument for &#39;newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># For ACO-R, *bounds* is required</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;acor&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AttributeError</span>: <span class="n">Missing required *bounds* argument for &#39;acor&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># fit doesn&#39;t support the *iterate* argument</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;steepest&#39;</span><span class="p">,</span> <span class="n">iterate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AttributeError</span>: <span class="n">Invalid argument &#39;iterate&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># You can only pass arguments for that specific solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;newton&#39;</span><span class="p">,</span> <span class="n">lamb</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AttributeError</span>: <span class="n">Invalid argument &#39;lamb&#39; for &#39;newton&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="fatiando.inversion.base.Misfit.estimate_">
<tt class="descname">estimate_</tt><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.estimate_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.estimate_" title="Permalink to this definition">¶</a></dt>
<dd><p>The current estimate.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">May be a formatted version of the parameter vector. It is
recommened that you use this when accessing the estimate and use
<a class="reference internal" href="#fatiando.inversion.base.Misfit.p_" title="fatiando.inversion.base.Misfit.p_"><tt class="xref py py-meth docutils literal"><span class="pre">p_</span></tt></a> when you want the raw
parameter vector.</p>
</div>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">1d-array or None</span></dt>
<dd><p class="first last">The parameter vector. None, if
<a class="reference internal" href="#fatiando.inversion.base.Misfit.fit" title="fatiando.inversion.base.Misfit.fit"><tt class="xref py py-meth docutils literal"><span class="pre">fit</span></tt></a> hasn&#8217;t been called
yet.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Misfit.fit">
<tt class="descname">fit</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve for the parameter vector that minimizes this objective function.</p>
<p>Uses the optimization method and parameters defined using the
<a class="reference internal" href="#fatiando.inversion.base.Misfit.config" title="fatiando.inversion.base.Misfit.config"><tt class="xref py py-meth docutils literal"><span class="pre">config</span></tt></a> method.</p>
<p>The estimated parameter vector can be accessed through the
<a class="reference internal" href="#fatiando.inversion.base.Misfit.p_" title="fatiando.inversion.base.Misfit.p_"><tt class="xref py py-meth docutils literal"><span class="pre">p_</span></tt></a> property. A (possibly)
formatted version (converted to a more manageble type) of the estimate
can be accessed through
<a class="reference internal" href="#fatiando.inversion.base.Misfit.estimate_" title="fatiando.inversion.base.Misfit.estimate_"><tt class="xref py py-meth docutils literal"><span class="pre">estimate_</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Misfit.jacobian">
<tt class="descname">jacobian</tt><big>(</big><em>p</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.jacobian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.jacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Jacobian matrix evaluated at a given parameter vector.</p>
<p>The Jacobian matrix is cached in memory, so passing the same
parameter vector again will not trigger a re-calculation. However, only
one matrix is cached at a time.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">1d-array or None</span></dt>
<dd><p class="first last">The parameter vector. If the problem is linear, pass <tt class="docutils literal"><span class="pre">None</span></tt></p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>jacobian <span class="classifier-delimiter">:</span> <span class="classifier">2d-array</span></dt>
<dd><p class="first last">The Jacobian matrix</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Misfit.linear">
<tt class="descname">linear</tt><big>(</big><em>precondition=True</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve for the parameter vector assuming that the problem is linear.</p>
<p>See <a class="reference internal" href="inversion.solvers.html#fatiando.inversion.solvers.linear" title="fatiando.inversion.solvers.linear"><tt class="xref py py-func docutils literal"><span class="pre">fatiando.inversion.solvers.linear</span></tt></a> for more details.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>precondition <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">If True, will use Jacobi preconditioning.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>estimate <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The estimated parameter vector</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="fatiando.inversion.base.Misfit.p_">
<tt class="descname">p_</tt><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.p_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.p_" title="Permalink to this definition">¶</a></dt>
<dd><p>The current estimated parameter vector.</p>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">1d-array or None</span></dt>
<dd><p class="first last">The parameter vector. None, if
<a class="reference internal" href="#fatiando.inversion.base.Misfit.fit" title="fatiando.inversion.base.Misfit.fit"><tt class="xref py py-meth docutils literal"><span class="pre">fit</span></tt></a> hasn&#8217;t been called
yet.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Misfit.predicted">
<tt class="descname">predicted</tt><big>(</big><em>p=None</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.predicted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.predicted" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the predicted data for a given parameter vector.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">1d-array or None</span></dt>
<dd><p class="first last">The parameter vector used to calculate the predicted data. If None,
will use the current estimate stored in <tt class="docutils literal"><span class="pre">estimate_</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>predicted <span class="classifier-delimiter">:</span> <span class="classifier">1d-array or list of 1d-arrays</span></dt>
<dd><p class="first last">The predicted data. If this is the sum of 1 or more Misfit
instances, will return the predicted data from each of the summed
misfits in the order of the sum.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Misfit.residuals">
<tt class="descname">residuals</tt><big>(</big><em>p=None</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the residuals vector (observed - predicted data).</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">1d-array or None</span></dt>
<dd><p class="first last">The parameter vector used to calculate the residuals. If None, will
use the current estimate stored in <tt class="docutils literal"><span class="pre">estimate_</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>residuals <span class="classifier-delimiter">:</span> <span class="classifier">1d-array or list of 1d-arrays</span></dt>
<dd><p class="first last">The residual vector. If this is the sum of 1 or more Misfit
instances, will return the residual vector from each of the summed
misfits in the order of the sum.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Misfit.set_weights">
<tt class="descname">set_weights</tt><big>(</big><em>weights</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.set_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.set_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the data weights array.</p>
<p>See <a class="reference internal" href="#fatiando.inversion.base.Misfit" title="fatiando.inversion.base.Misfit"><tt class="xref py py-class docutils literal"><span class="pre">Misfit</span></tt></a> for more information.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">A vector with the data weights.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Misfit.subset">
<tt class="descname">subset</tt><big>(</big><em>indices</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Misfit.subset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Misfit.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a shallow copy of this object with only a subset of the data.</p>
<p>Additionally cuts the <em>positional</em> arguments and Jacobian matrix (if it
is present in the cache).</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">list of ints or 1d-array of bools</span></dt>
<dd><p class="first last">The indices that correspond to the subset.</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>subset <span class="classifier-delimiter">:</span> <span class="classifier">Misfit</span></dt>
<dd><p class="first last">A copy of this object</p>
</dd>
</dl>
</li>
</ul>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">Misfit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">]),</span>
<span class="gp">... </span>                <span class="n">positional</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;x&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">100</span><span class="p">])},</span>
<span class="gp">... </span>                <span class="n">model</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;d&#39;</span><span class="p">:</span><span class="mi">12</span><span class="p">},</span>
<span class="gp">... </span>                <span class="n">nparams</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Populate the cache to show what happens to it</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;jacobian&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;hessian&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;predicted&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Get the subset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">subset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">ndata</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([ 2, 10])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">positional</span>
<span class="go">{&#39;x&#39;: array([  5, 100])}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">model</span>
<span class="go">{&#39;d&#39;: 12}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;jacobian&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span>
<span class="go">array([[3, 4],</span>
<span class="go">       [7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;hessian&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;predicted&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># The original solver stays the same</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([ 1,  2,  3, 10])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">positional</span>
<span class="go">{&#39;x&#39;: array([  4,   5,   6, 100])}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">model</span>
<span class="go">{&#39;d&#39;: 12}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;jacobian&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6],</span>
<span class="go">       [7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;hessian&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span>
<span class="go">array([[ 1.,  1.],</span>
<span class="go">       [ 1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;predicted&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span>
<span class="go">array([ 1.,  1.,  1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Can also use a numpy array of booleans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">ndata</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">data</span>
<span class="go">array([ 2, 10])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">positional</span>
<span class="go">{&#39;x&#39;: array([  5, 100])}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">model</span>
<span class="go">{&#39;d&#39;: 12}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;jacobian&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span>
<span class="go">array([[3, 4],</span>
<span class="go">       [7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;hessian&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sub</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s">&#39;predicted&#39;</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fatiando.inversion.base.Objective">
<em class="property">class </em><tt class="descclassname">fatiando.inversion.base.</tt><tt class="descname">Objective</tt><big>(</big><em>nparams</em>, <em>islinear</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An objective function for an inverse problem.</p>
<p>Objective functions know how to calculate their value, gradient and/or
Hessian matrix for a given parameter vector <em>p</em>. The methods that implement
these should have the following format:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculate the value of the objetive function.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * p : 1d-array or None</span>
<span class="sd">        The parameter vector.</span>

<span class="sd">    Returns:</span>

<span class="sd">    * value : float</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">_get_hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculates the Hessian matrix.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * p : 1d-array</span>
<span class="sd">        The parameter vector where the Hessian is evaluated</span>

<span class="sd">    Returns:</span>

<span class="sd">    * hessian : 2d-array</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">_get_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The gradient vector.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    * p : 1d-array</span>
<span class="sd">        The parameter vector where the gradient is evaluated</span>

<span class="sd">    Returns:</span>

<span class="sd">    * gradient : 1d-array</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>These methods are problem specific and need to be implemented when
subclassing <em>Objective</em>.</p>
<p><em>Objective</em> has methods that find the parameter vector that minimizes it:</p>
<ul class="simple">
<li><a class="reference internal" href="#fatiando.inversion.base.Objective.newton" title="fatiando.inversion.base.Objective.newton"><tt class="xref py py-meth docutils literal"><span class="pre">newton</span></tt></a></li>
<li><a class="reference internal" href="#fatiando.inversion.base.Objective.levmarq" title="fatiando.inversion.base.Objective.levmarq"><tt class="xref py py-meth docutils literal"><span class="pre">levmarq</span></tt></a></li>
<li><a class="reference internal" href="#fatiando.inversion.base.Objective.steepest" title="fatiando.inversion.base.Objective.steepest"><tt class="xref py py-meth docutils literal"><span class="pre">steepest</span></tt></a></li>
<li><a class="reference internal" href="#fatiando.inversion.base.Objective.acor" title="fatiando.inversion.base.Objective.acor"><tt class="xref py py-meth docutils literal"><span class="pre">acor</span></tt></a></li>
</ul>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>nparams <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of parameters the objective function takes.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>islinear <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">Wether the functions is linear with respect to the parameters.</p>
</dd>
</dl>
</li>
</ul>
<p>Operations:</p>
<p>For joint inversion and regularization, you can add <em>Objective</em>
instances together and multiply them by scalars (i.e., regularization
parameters):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyObjective</span><span class="p">(</span><span class="n">Objective</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">(</span><span class="n">MyObjective</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span> <span class="o">=</span> <span class="n">scale</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scalar</span><span class="o">*</span><span class="n">p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">MyObjective</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">MyObjective</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-12</span>
</pre></div>
</div>
<dl class="method">
<dt id="fatiando.inversion.base.Objective.acor">
<tt class="descname">acor</tt><big>(</big><em>bounds</em>, <em>nants=None</em>, <em>archive_size=None</em>, <em>maxit=1000</em>, <em>diverse=0.5</em>, <em>evap=0.85</em>, <em>seed=None</em>, <em>iterate=False</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Objective.acor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Objective.acor" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimize the objective function using ACO-R.</p>
<p>See <a class="reference internal" href="inversion.solvers.html#fatiando.inversion.solvers.acor" title="fatiando.inversion.solvers.acor"><tt class="xref py py-func docutils literal"><span class="pre">fatiando.inversion.solvers.acor</span></tt></a> for more details.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>bounds <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The bounds of the search space. If only two values are given,
will interpret as the minimum and maximum, respectively, for all
parameters.
Alternatively, you can given a minimum and maximum for each
parameter, e.g., for a problem with 3 parameters you could give
<cite>bounds = [min1, max1, min2, max2, min3, max3]</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>nants <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of ants to use in the search. Defaults to the number
of parameters.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>archive_size <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of solutions to keep in the solution archive.
Defaults to 10 x nants</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>maxit <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of iterations to run.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>diverse <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scalar from 0 to 1, non-inclusive, that controls how much better
solutions are favored when constructing new ones.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>evap <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The pheromone evaporation rate (evap &gt; 0). Controls how spread
out the search is.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>seed <span class="classifier-delimiter">:</span> <span class="classifier">None or int</span></dt>
<dd><p class="first last">Seed for the random number generator.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>iterate <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">If True, will return an iterator that yields one estimated
parameter vector at a time for each iteration of the algorithm</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>estimate <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The best estimate</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Objective.gradient">
<tt class="descname">gradient</tt><big>(</big><em>p</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Objective.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Objective.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>The gradient vector of this objective function at <em>p</em></p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The parameter vector</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>gradient <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The gradient of this Objective function. If this is the sum of 1 or
more objective functions, gradient will be the sum of the gradients</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Objective.hessian">
<tt class="descname">hessian</tt><big>(</big><em>p</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Objective.hessian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Objective.hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>The Hessian matrix of this objective function at <em>p</em></p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The parameter vector</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>hessian <span class="classifier-delimiter">:</span> <span class="classifier">2d-array</span></dt>
<dd><p class="first last">The Hessian of this Objective function. If this is the sum of 1 or
more objective functions, hessian will be the sum of the Hessians</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Objective.levmarq">
<tt class="descname">levmarq</tt><big>(</big><em>initial</em>, <em>maxit=30</em>, <em>maxsteps=10</em>, <em>lamb=1</em>, <em>dlamb=2</em>, <em>tol=1e-05</em>, <em>precondition=True</em>, <em>iterate=False</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Objective.levmarq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Objective.levmarq" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve using the Levemberg-Marquardt algorithm.</p>
<p>See <a class="reference internal" href="inversion.solvers.html#fatiando.inversion.solvers.levmarq" title="fatiando.inversion.solvers.levmarq"><tt class="xref py py-func docutils literal"><span class="pre">fatiando.inversion.solvers.levmarq</span></tt></a> for more details.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The initial estimate for the gradient descent.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>maxit <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The maximum number of iterations allowed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>maxsteps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The maximum number of times to try to take a step before giving
up</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>lamb <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Initial amount of step regularization. The larger this is, the
more the algorithm will resemble Steepest Descent in the initial
iterations.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dlamb <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Factor by which <em>lamb</em> is divided or multiplied when taking steps</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The convergence criterion. The lower it is, the more steps are
permitted</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>precondition <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">If True, will use Jacobi preconditioning</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>iterate <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">If True, will return an iterator that yields one estimated
parameter vector at a time for each iteration of the algorithm</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>estimate <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The estimated parameter vector</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Objective.newton">
<tt class="descname">newton</tt><big>(</big><em>initial</em>, <em>maxit=30</em>, <em>tol=1e-05</em>, <em>precondition=True</em>, <em>iterate=False</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Objective.newton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Objective.newton" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimize an objective function using Newton&#8217;s method.</p>
<p>See <a class="reference internal" href="inversion.solvers.html#fatiando.inversion.solvers.newton" title="fatiando.inversion.solvers.newton"><tt class="xref py py-func docutils literal"><span class="pre">fatiando.inversion.solvers.newton</span></tt></a> for more details.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The initial estimate for the gradient descent.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>maxit <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The maximum number of iterations allowed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The convergence criterion. The lower it is, the more steps are
permitted.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>precondition <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">If True, will use Jacobi preconditioning.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>iterate <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">If True, will return an iterator that yields one estimated
parameter vector at a time for each iteration of the algorithm</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>estimate <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The estimated parameter vector</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Objective.steepest">
<tt class="descname">steepest</tt><big>(</big><em>initial</em>, <em>stepsize=0.1</em>, <em>maxsteps=30</em>, <em>maxit=1000</em>, <em>tol=1e-05</em>, <em>iterate=False</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Objective.steepest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Objective.steepest" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimize an objective function using the Steepest Descent method.</p>
<p>See <a class="reference internal" href="inversion.solvers.html#fatiando.inversion.solvers.steepest" title="fatiando.inversion.solvers.steepest"><tt class="xref py py-func docutils literal"><span class="pre">fatiando.inversion.solvers.steepest</span></tt></a> for more details.</p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>initial <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The initial estimate for the gradient descent.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>maxit <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The maximum number of iterations allowed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>maxsteps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The maximum number of times to try to take a step before giving
up</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>stepsize <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Initial amount of step step size.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The convergence criterion. The lower it is, the more steps are
permitted.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>iterate <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">If True, will return an iterator that yields one estimated
parameter vector at a time for each iteration of the algorithm</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>estimate <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The estimated parameter vector</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fatiando.inversion.base.Objective.value">
<tt class="descname">value</tt><big>(</big><em>p</em><big>)</big><a class="reference internal" href="../_modules/fatiando/inversion/base.html#Objective.value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#fatiando.inversion.base.Objective.value" title="Permalink to this definition">¶</a></dt>
<dd><p>The value (scalar) of this objective function at <em>p</em></p>
<p>Parameters:</p>
<ul>
<li><dl class="first docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">1d-array</span></dt>
<dd><p class="first last">The parameter vector</p>
</dd>
</dl>
</li>
</ul>
<p>Returns:</p>
<ul>
<li><dl class="first docutils">
<dt>value <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The value of this Objective function. If this is the sum of 1 or
more objective functions, value will be the sum of the values.</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

</dd></dl>

</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="inversion.solvers.html" class="btn btn-neutral float-right" title="Optimization routines (fatiando.inversion.solvers)"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="inversion.html" class="btn btn-neutral" title="Inverse problems framework (fatiando.inversion)"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2014, Leonardo Uieda.
      Last updated on Mar 05, 2015.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>